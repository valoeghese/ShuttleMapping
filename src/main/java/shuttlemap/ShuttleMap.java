/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package shuttlemap;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UncheckedIOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Stream;

import org.cadixdev.bombe.type.signature.FieldSignature;
import org.cadixdev.bombe.type.signature.MethodSignature;
import org.cadixdev.lorenz.MappingSet;
import org.cadixdev.lorenz.io.proguard.ProGuardFormat;
import org.cadixdev.lorenz.io.proguard.ProGuardReader;
import org.cadixdev.lorenz.model.ClassMapping;
import org.cadixdev.lorenz.model.FieldMapping;
import org.cadixdev.lorenz.model.InnerClassMapping;
import org.cadixdev.lorenz.model.MethodMapping;

import net.fabricmc.lorenztiny.TinyMappingFormat;
import net.fabricmc.mapping.reader.v2.MappingParseException;
import tk.valoeghese.motjin.map.parser.ObfuscationMap;

public class ShuttleMap {
	public static void main(String[] args) throws MappingParseException, IOException {
		MappingSet o2m = MappingSet.create();

		try (BufferedReader clientBufferedReader = Files.newBufferedReader(Paths.get("./client.txt"), StandardCharsets.UTF_8);
				//BufferedReader serverBufferedReader = Files.newBufferedReader(Paths.get("./server.txt"), StandardCharsets.UTF_8)
				) {
			try (ProGuardReader proGuardReaderClient = new ProGuardReader(clientBufferedReader);
					//ProGuardReader proGuardReaderServer = new ProGuardReader(serverBufferedReader)
					) {
				proGuardReaderClient.read(o2m);
				//				proGuardReaderServer.read(mojang); I don't think the server is strictly neccesary
			}
		}

		o2m = o2m.reverse();

		MappingSet o2i = TinyMappingFormat.LEGACY.read(
				Paths.get("./mappings.tiny"),
				"official", "intermediary");

		writeTinyLorenz("shuttle.tiny", o2i, o2m);
	}

	public static void oldMain() throws MappingParseException, IOException {
		MappingSet mojang = new ProGuardFormat().createReader(
				Files.newInputStream(Paths.get("./client.txt")))
				.read().reverse(); // official -> mojang

		ObfuscationMap intermediary = ObfuscationMap.parseTiny("./mappings.tiny");

		writeTiny("shuttle.tiny", intermediary, mojang);
	}

	// from motjin
	private static void writeTinyLorenz(String file, MappingSet o2i, MappingSet o2m) {
		try (PrintWriter writer = new PrintWriter(file, "UTF-8")) {
			writer.println("v1\tofficial\tintermediary\tnamed");

			classes(o2i).forEach(o2iClass -> {
				StringBuilder output = new StringBuilder();
				System.out.println("Mapping\t" + o2iClass.getFullObfuscatedName());

				// Add mojang name to intermediary class entry
				Optional<? extends ClassMapping<?, ?>> opto2mClass = o2m.getClassMapping(o2iClass.getFullObfuscatedName());

				if (opto2mClass.isPresent()) {
					// print out
					output.append("CLASS\t" + o2iClass.getFullObfuscatedName() + "\t" + o2iClass.getFullDeobfuscatedName() + "\t" + opto2mClass.get().getFullDeobfuscatedName());
					ClassMapping<?, ?> o2mClass = opto2mClass.get();

					// Process Fields
					o2iClass.getFieldMappings().forEach(o2iField -> {
						// Get field entry and set final column mapping
						Optional<? extends FieldMapping> opto2mField = o2mClass.getFieldMapping(o2iField.getSignature());

						if (opto2mField.isPresent()) {
							FieldMapping o2mField = opto2mField.get();

							output.append("\nFIELD\t")
							.append(o2iClass.getFullObfuscatedName()).append('\t')
							.append(o2iField.getType().get()).append('\t')
							.append(o2iField.getObfuscatedName()).append('\t')
							.append(o2iField.getDeobfuscatedName()).append('\t')
							.append(o2mField.getDeobfuscatedName()); // last line differs
						} else {
							output.append("\nFIELD\t")
							.append(o2iClass.getFullObfuscatedName()).append('\t')
							.append(o2iField.getType().get()).append('\t')
							.append(o2iField.getObfuscatedName()).append('\t')
							.append(o2iField.getDeobfuscatedName()).append('\t')
							.append(o2iField.getDeobfuscatedName()); // last line differs
						}
					});

					// Process Methods
					o2iClass.getMethodMappings().forEach(o2iMethod -> {
						// Get method entry and set final column mapping
						Optional<? extends MethodMapping> opto2mMethod = o2mClass.getMethodMapping(o2iMethod.getSignature());

						if (opto2mMethod.isPresent()) {
							String shuttlePrefix = o2iMethod.getFullDeobfuscatedName().startsWith("method") ? "mc_" : "";
							MethodMapping o2mMethod = opto2mMethod.get();

							output.append("\nMETHOD\t")
							.append(o2iClass.getFullObfuscatedName()).append('\t')
							.append(o2iMethod.getDescriptor()).append('\t')
							.append(o2iMethod.getObfuscatedName()).append('\t')
							.append(o2iMethod.getDeobfuscatedName()).append('\t')
							.append(shuttlePrefix + o2mMethod.getDeobfuscatedName()); // last line differs
						} else {
							output.append("\nMETHOD\t")
							.append(o2iClass.getFullObfuscatedName()).append('\t')
							.append(o2iMethod.getDescriptor()).append('\t')
							.append(o2iMethod.getObfuscatedName()).append('\t')
							.append(o2iMethod.getDeobfuscatedName()).append('\t')
							.append(o2iMethod.getDeobfuscatedName()); // last line differs
						}
					});
				} else {
					// print out
					output.append("CLASS\t" + o2iClass.getFullObfuscatedName() + "\t" + o2iClass.getFullDeobfuscatedName() + "\t" + o2iClass.getFullDeobfuscatedName());

					// Process Fields
					o2iClass.getFieldMappings().forEach(o2iField -> {
						output.append("\nFIELD\t")
						.append(o2iClass.getFullObfuscatedName()).append('\t')
						.append(o2iField.getType().get()).append('\t')
						.append(o2iField.getObfuscatedName()).append('\t')
						.append(o2iField.getDeobfuscatedName()).append('\t')
						.append(o2iField.getDeobfuscatedName());
					});

					// Process Methods
					o2iClass.getMethodMappings().forEach(o2iMethod -> {
						output.append("\nMETHOD\t")
						.append(o2iClass.getFullObfuscatedName()).append('\t')
						.append(o2iMethod.getDescriptor()).append('\t')
						.append(o2iMethod.getObfuscatedName()).append('\t')
						.append(o2iMethod.getDeobfuscatedName()).append('\t')
						.append(o2iMethod.getDeobfuscatedName()); // last line differs
					});
				}

				writer.println(output.toString());
			});
		} catch (FileNotFoundException | UnsupportedEncodingException e) {
			throw new UncheckedIOException(e);
		}
	}

	private static Stream<ClassMapping<?, ?>> classes(MappingSet map) {
		List<ClassMapping<?, ?>> result = new ArrayList<>();
		for (ClassMapping<?, ?> map_ : map.getTopLevelClassMappings()) ic(map_, result::add);
		return result.stream();
	}

	private static void ic(ClassMapping<?, ?> preMap, Consumer<ClassMapping<?, ?>> callback) {
		callback.accept(preMap);

		for (InnerClassMapping map : preMap.getInnerClassMappings()) {
			ic(map, callback);
		}
	}

	// from motjin
	private static void writeTiny(String file, ObfuscationMap intermediary, MappingSet mojang) {
		try (PrintWriter writer = new PrintWriter(file, "UTF-8")) {
			writer.println("v1\tofficial\tintermediary\tnamed");

			intermediary.forEachObf((obf, intermediaryEntry) -> {
				StringBuilder output = new StringBuilder();
				System.out.println("Mapping\t" + intermediaryEntry.getMappedName());

				// Add mojang name to intermediary class entry
				Optional<? extends ClassMapping<?, ?>> mojmapEntry = mojang.computeClassMapping(obf);

				if (mojmapEntry.isPresent()) {
					intermediaryEntry.setFinalColumnMapping(mojmapEntry.get().getDeobfuscatedName());
				}

				// Add to output tiny
				output.append(intermediaryEntry.toString());

				if (mojmapEntry.isPresent()) {
					ClassMapping<?, ?> mojmapEntry_ = mojmapEntry.get();

					// Process Fields
					intermediaryEntry.fields.forEach(intermediaryFieldEntry -> {
						// Get field entry and set final column mapping
						Optional<? extends FieldMapping> mojmapFieldEntry = mojmapEntry_.computeFieldMapping(FieldSignature.of(intermediaryFieldEntry.obfName, intermediaryFieldEntry.descriptor));

						if (mojmapFieldEntry.isPresent()) {
							intermediaryFieldEntry.setFinalColumnMapping(mojmapFieldEntry.get().getDeobfuscatedName());
						}

						// Add to output
						output.append("\n").append(intermediaryFieldEntry.toString());
					});

					// Process Methods
					intermediaryEntry.methods.forEach(intermediaryMethodEntry -> {
						// Get method entry and set final column mapping
						Optional<? extends MethodMapping> mojmapMethodEntry = mojmapEntry_.getMethodMapping(MethodSignature.of(intermediaryMethodEntry.obfName, intermediaryMethodEntry.signature));

						if (mojmapMethodEntry.isPresent()) {
							if (intermediaryMethodEntry.getMappedName().startsWith("method")) {
								intermediaryMethodEntry.setFinalColumnMapping("mc_" + mojmapMethodEntry.get().getDeobfuscatedName());
							} else {
								intermediaryMethodEntry.setFinalColumnMapping(mojmapMethodEntry.get().getDeobfuscatedName());
							}
						}

						// Add to output
						output.append("\n").append(intermediaryMethodEntry.toString());
					});

					writer.println(output.toString());
				}
			});
		} catch (FileNotFoundException | UnsupportedEncodingException e) {
			throw new UncheckedIOException(e);
		}
	}
}
